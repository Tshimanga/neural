-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Neural Networks in native Haskell
--   
--   The goal of <a>neural</a> is to provide a modular and flexible neural
--   network library written in native Haskell.
--   
--   Features include
--   
--   <ul>
--   <li><i>composability</i> via <a>Arrow</a> instances and
--   <a>pipes</a>,</li>
--   <li><i>automatic differentiation</i> for automatic gradient descent/
--   backpropagation training (using Edward Kmett's fabulous <a>ad</a>
--   library).</li>
--   </ul>
--   
--   The idea is to be able to easily define new components and wire them
--   up in flexible, possibly complicated ways (convolutional deep networks
--   etc.).
--   
--   Two examples are included as proof of concept:
--   
--   <ul>
--   <li>A simple neural network that approximates the sqrt function on
--   [0,4].</li>
--   <li>A slightly more complicated neural network that solves the famous
--   <a>Iris flower</a> problem.</li>
--   </ul>
--   
--   The library is still very much experimental at this point.
@package neural
@version 0.1.0.1


-- | This module provides various utilities for working with lists.
module Data.Utils.List

-- | Splits off the last element of a non-empty list.
--   
--   <pre>
--   &gt;&gt;&gt; splitLast [1, 2, 3]
--   Just ([1,2],3)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; splitLast []
--   Nothing
--   </pre>
splitLast :: [a] -> Maybe ([a], a)

-- | Given a valid index, returns the list element at the index and the
--   remaining elements.
--   
--   <pre>
--   &gt;&gt;&gt; pick 1 [1,2,3,4]
--   (2,[1,3,4])
--   </pre>
pick :: Int -> [a] -> (a, [a])

-- | Distributes the elements of a list as uniformly as possible amongst a
--   specified number of groups.
--   
--   <pre>
--   &gt;&gt;&gt; distribute 3 [1,2,3,4,5]
--   [[3],[4,1],[5,2]]
--   </pre>
distribute :: Int -> [a] -> [[a]]

-- | Pads a litst with a provided element on the left.
--   
--   <pre>
--   &gt;&gt;&gt; pad 4 'x' "oo"
--   "xxoo"
--   </pre>
pad :: Int -> a -> [a] -> [a]

-- | <tt><a>ListEditorT</a> a m</tt> is a monad transformer for editting
--   lists of type <tt>[a]</tt>.
data ListEditorT a m b

-- | Runs the editor.
editListT :: Monad m => ListEditorT a m () -> [a] -> m [a]

-- | Replaces the list at the "cursor" with the provided list.
editT :: Monad m => [a] -> ListEditorT a m ()

-- | Tries to move the "cursor" to the left.
tryLeftT :: Monad m => ListEditorT a m Bool

-- | Tries to move the "cursor" to the right.
tryRightT :: Monad m => ListEditorT a m Bool

-- | Gets the list under the "cursor".
focusT :: Monad m => ListEditorT a m [a]

-- | Monad for pure list editting.
type ListEditor a = ListEditorT a Identity

-- | Runs the pure editor.
--   
--   <pre>
--   &gt;&gt;&gt; editList (do _ &lt;- tryRightT; editT [3,2]) [1,2,3]
--   [1,3,2]
--   </pre>
editList :: ListEditor a () -> [a] -> [a]

-- | Gets all pairs of adjacent list elements.
--   
--   <pre>
--   &gt;&gt;&gt; pairs "Haskell"
--   [('H','a'),('a','s'),('s','k'),('k','e'),('e','l'),('l','l')]
--   </pre>
pairs :: [a] -> [(a, a)]

-- | Gets the first index of the provided element in the list or
--   <a>Nothing</a> if it is not in the list.
--   
--   <pre>
--   &gt;&gt;&gt; indexOf "Haskell" 'l'
--   Just 5
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; indexOf "Haskell" 'y'
--   Nothing
--   </pre>
indexOf :: Eq a => [a] -> a -> Maybe Int
instance GHC.Base.Monad m => Control.Monad.State.Class.MonadState (Data.Utils.List.LZ a) (Data.Utils.List.ListEditorT a m)
instance GHC.Base.Monad m => GHC.Base.Monad (Data.Utils.List.ListEditorT a m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Data.Utils.List.ListEditorT a m)
instance GHC.Base.Functor m => GHC.Base.Functor (Data.Utils.List.ListEditorT a m)


-- | This module provides utilities for working with module <a>Random</a>.
module Data.Utils.Random

-- | Picks a random element of the list and returns that element and the
--   remaining elements.
--   
--   <pre>
--   &gt;&gt;&gt; evalRand (pickR' "Haskell") (mkStdGen 4712)
--   ('s',"Hakell")
--   </pre>
pickR' :: MonadRandom m => [a] -> m (a, [a])

-- | Picks a random element of the list.
--   
--   <pre>
--   &gt;&gt;&gt; evalRand (pickR "Haskell") (mkStdGen 4712)
--   's'
--   </pre>
pickR :: MonadRandom m => [a] -> m a

-- | Takes the specified number of random elements from the list. Returns
--   those elements and the remaining elements.
--   
--   <pre>
--   &gt;&gt;&gt; evalRand (takeR' 3 "Haskell") (mkStdGen 4712)
--   ("aks","Hell")
--   </pre>
takeR' :: MonadRandom m => Int -> [a] -> m ([a], [a])

-- | Takes the specified number of random elements from the list.
--   
--   <pre>
--   &gt;&gt;&gt; evalRand (takeR 3 "Haskell") (mkStdGen 4712)
--   "aks"
--   </pre>
takeR :: MonadRandom m => Int -> [a] -> m [a]

-- | Shuffles an array with the <a>Fisher-Yates algorithm</a>.
fisherYates :: MonadRandom m => Array Int a -> m (Array Int a)

-- | Shuffles an list with the <a>Fisher-Yates algorithm</a>.
--   
--   <pre>
--   &gt;&gt;&gt; evalRand (shuffleR "Haskell") (mkStdGen 4712)
--   "skalHle"
--   </pre>
shuffleR :: MonadRandom m => [a] -> m [a]

-- | Uses the <a>Box-Muller transform</a> to sample the standard normal
--   distribution (zero expectation, unit variance).
--   
--   <pre>
--   &gt;&gt;&gt; evalRand (replicateM 5 boxMuller) (mkStdGen 1234) :: [Float]
--   [0.61298496,-0.19325614,4.4974413e-2,-0.31926495,-1.1109064]
--   </pre>
boxMuller :: (Floating a, Random a, Eq a, MonadRandom m) => m a

-- | Uses the <a>Box-Muller transform</a> to sample a normal distribution
--   with specified mean and stadard deviation.
--   
--   <pre>
--   &gt;&gt;&gt; evalRand (replicateM 5 $ boxMuller' 10 2) (mkStdGen 1234) :: [Float]
--   [11.22597,9.613487,10.089949,9.36147,7.7781873]
--   </pre>
boxMuller' :: (Floating a, Random a, Eq a, MonadRandom m) => a -> a -> m a

-- | Randomly selects the specified number of elements of a <i>weighted</i>
--   list.
--   
--   <pre>
--   &gt;&gt;&gt; evalRand (roulette 10 [('x', 1 :: Double), ('y', 2)]) (mkStdGen 1000)
--   "yxxyyyyxxy"
--   </pre>
roulette :: (Ord b, Fractional b, Random b, MonadRandom m) => Int -> [(a, b)] -> m [a]


-- | This module provides utilities for working with statistics.
module Data.Utils.Statistics

-- | A type for representing probabilities.
data Probability a

-- | Smart constructor for probabilities.
--   
--   <pre>
--   &gt;&gt;&gt; probability (0.7 :: Double)
--   Probability {fromProbability = 0.7}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; probability (1.2 :: Double)
--   Probability {fromProbability = 1.0}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; probability (-0.3 :: Double)
--   Probability {fromProbability = 0.0}
--   </pre>
probability :: RealFloat a => a -> Probability a
fromProbability :: Probability a -> a

-- | Returns number of elements, mean and variance of a collection of
--   elements.
--   
--   <pre>
--   &gt;&gt;&gt; countMeanVar [1, 2, 3, 4 :: Float]
--   (4,2.5,1.25)
--   </pre>
countMeanVar :: Fractional a => [a] -> (Int, a, a)

-- | Calculates the mean of a collection of elements.
--   
--   <pre>
--   &gt;&gt;&gt; mean [1 .. 5 :: Float]
--   3.0
--   </pre>
mean :: Fractional a => [a] -> a

-- | Calculates the <a>area under the curve</a>.
--   
--   <pre>
--   &gt;&gt;&gt; auc [(1, False), (2, True), (3, False), (4, True), (5, False), (6, True), (7, True)]
--   Probability {fromProbability = 0.75}
--   </pre>
auc :: Ord a => [(a, Bool)] -> Probability Double

-- | Calculates the <a>area under the curve</a> for <i>weighted</i>
--   samples.
--   
--   <pre>
--   &gt;&gt;&gt; auc' [(1, (1 :: Double), False), (2, 0.5, True), (3, 1, False), (4, 1, True), (5, 1, False), (6, 1, True), (7, 1, True)]
--   0.8095238095238095
--   </pre>
auc' :: (Ord a, Fractional b) => [(a, b, Bool)] -> b

-- | Rounds a <a>Double</a> to the specified number of decimals.
--   
--   <pre>
--   &gt;&gt;&gt; round' 3 (2/3)
--   0.667
--   </pre>
round' :: Int -> Double -> Double
instance GHC.Base.Functor Data.Utils.Statistics.Probability
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Utils.Statistics.Probability a)
instance GHC.Num.Num a => GHC.Num.Num (Data.Utils.Statistics.Probability a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Utils.Statistics.Probability a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Utils.Statistics.Probability a)
instance GHC.Read.Read a => GHC.Read.Read (Data.Utils.Statistics.Probability a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Utils.Statistics.Probability a)


-- | This module defines utility functions for <i>arrows</i>.
module Data.Utils.Arrow

-- | Arrows implementing <a>ArrowConvolve</a> can be mapped over
--   containers. This means that every functor (<tt>f :: Hask -&gt;
--   Hask</tt>) lifts to a functor (<tt>a -&gt; a</tt>).
--   
--   Instances should satisfy the following laws:
--   
--   <ul>
--   <li><pre>convolve id = id</pre></li>
--   <li><pre>convolve (g . h) = convolve g . convolve h</pre></li>
--   <li><pre>convolve . arr = arr . fmap</pre></li>
--   </ul>
class Arrow a => ArrowConvolve a
convolve :: (ArrowConvolve a, Functor f) => a b c -> a (f b) (f c)

-- | A function suitable to define the canonical <a>Functor</a> instance
--   for arrows.
fmapArr :: Arrow a => (c -> d) -> a b c -> a b d

-- | A function to define <a>pure</a> for arrows. Combining this with
--   <a>apArr</a>, the canonical <a>Applicative</a> instance for arrows can
--   easily be defined.
pureArr :: Arrow a => c -> a b c

-- | A function to define <tt>(<a>&lt;*&gt;</a>)</tt> for arrows. Combining
--   this with <a>pureArr</a>, the canonical <a>Applicative</a> instance
--   for arrows can easily be defined.
apArr :: Arrow a => a b (c -> d) -> a b c -> a b d

-- | A function suitable to define the canonical <a>Profunctor</a> instance
--   for arrows.
dimapArr :: Arrow a => (b -> c) -> (d -> e) -> a c d -> a b e


-- | This module defines the numeric type <a>Analytic</a>, which has "built
--   in differentiation".
module Data.Utils.Analytic

-- | The numeric type <a>Analytic</a> is a wrapper around Edward Kmett's
--   <tt><a>Kahn</a> Double</tt> type. Using functions from Analytics to
--   Analytics, we automatically get numerically exact gradients. An number
--   of type <a>Analytic</a> is conceptionally a <a>Double</a> together
--   with an infinitesimal component.
data Analytic

-- | Converts a <a>Double</a> to an <a>Analytic</a> without infinitesimal
--   component.
fromDouble :: Double -> Analytic

-- | Tries to convert an <a>Analytic</a> to a <a>Double</a>. This
--   conversion will work if the <a>Analytic</a> has no infinitesimal
--   component.
fromAnalytic :: Analytic -> Maybe Double

-- | Computes the gradient of an analytic function and combines it with the
--   argument.
--   
--   <pre>
--   &gt;&gt;&gt; gradient (\_ d -&gt; d) (\[x, y] -&gt; x * x + 3 * y + 7) [2, 1]
--   (14.0,[4.0,3.0])
--   </pre>
gradient :: Traversable t => (Double -> Double -> a) -> (t Analytic -> Analytic) -> t Double -> (Double, t a)
instance GHC.Real.RealFrac Data.Utils.Analytic.Analytic
instance GHC.Float.RealFloat Data.Utils.Analytic.Analytic
instance GHC.Real.Real Data.Utils.Analytic.Analytic
instance GHC.Classes.Ord Data.Utils.Analytic.Analytic
instance GHC.Real.Fractional Data.Utils.Analytic.Analytic
instance GHC.Float.Floating Data.Utils.Analytic.Analytic
instance GHC.Classes.Eq Data.Utils.Analytic.Analytic
instance GHC.Num.Num Data.Utils.Analytic.Analytic
instance GHC.Show.Show Data.Utils.Analytic.Analytic


-- | This module simply reexports a selection of commonly used standard
--   types and functions.
module Data.MyPrelude

-- | A class of types that can be fully evaluated.
--   
--   <i>Since: 1.1.0.0</i>
class NFData a

-- | <a>rnf</a> should reduce its argument to normal form (that is, fully
--   evaluate all sub-components), and then return '()'.
--   
--   <h3><a>Generic</a> <a>NFData</a> deriving</h3>
--   
--   Starting with GHC 7.2, you can automatically derive instances for
--   types possessing a <a>Generic</a> instance.
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric #-}
--   
--   import GHC.Generics (Generic)
--   import Control.DeepSeq
--   
--   data Foo a = Foo a String
--                deriving (Eq, Generic)
--   
--   instance NFData a =&gt; NFData (Foo a)
--   
--   data Colour = Red | Green | Blue
--                 deriving Generic
--   
--   instance NFData Colour
--   </pre>
--   
--   Starting with GHC 7.10, the example above can be written more
--   concisely by enabling the new <tt>DeriveAnyClass</tt> extension:
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric, DeriveAnyClass #-}
--   
--   import GHC.Generics (Generic)
--   import Control.DeepSeq
--   
--   data Foo a = Foo a String
--                deriving (Eq, Generic, NFData)
--   
--   data Colour = Red | Green | Blue
--                 deriving (Generic, NFData)
--   </pre>
--   
--   <h3>Compatibility with previous <tt>deepseq</tt> versions</h3>
--   
--   Prior to version 1.4.0.0, the default implementation of the <a>rnf</a>
--   method was defined as
--   
--   <pre>
--   <a>rnf</a> a = <a>seq</a> a ()
--   </pre>
--   
--   However, starting with <tt>deepseq-1.4.0.0</tt>, the default
--   implementation is based on <tt>DefaultSignatures</tt> allowing for
--   more accurate auto-derived <a>NFData</a> instances. If you need the
--   previously used exact default <a>rnf</a> method implementation
--   semantics, use
--   
--   <pre>
--   instance NFData Colour where rnf x = seq x ()
--   </pre>
--   
--   or alternatively
--   
--   <pre>
--   {-# LANGUAGE BangPatterns #-}
--   instance NFData Colour where rnf !_ = ()
--   </pre>
rnf :: NFData a => a -> ()

-- | <a>&amp;</a> is a reverse application operator. This provides
--   notational convenience. Its precedence is one higher than that of the
--   forward application operator <a>$</a>, which allows <a>&amp;</a> to be
--   nested in <a>$</a>.
(&) :: a -> (a -> b) -> b

-- | View the value pointed to by a <a>Getter</a> or <a>Lens</a> or the
--   result of folding over all the results of a <a>Fold</a> or
--   <a>Traversal</a> that points at a monoidal values.
--   
--   This is the same operation as <a>view</a> with the arguments flipped.
--   
--   The fixity and semantics are such that subsequent field accesses can
--   be performed with (<a>.</a>).
--   
--   <pre>
--   &gt;&gt;&gt; (a,b)^._2
--   b
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ("hello","world")^._2
--   "world"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Complex
--   
--   &gt;&gt;&gt; ((0, 1 :+ 2), 3)^._1._2.to magnitude
--   2.23606797749979
--   </pre>
--   
--   <pre>
--   (<a>^.</a>) ::             s -&gt; <a>Getter</a> s a     -&gt; a
--   (<a>^.</a>) :: <a>Monoid</a> m =&gt; s -&gt; <a>Fold</a> s m       -&gt; m
--   (<a>^.</a>) ::             s -&gt; <a>Iso'</a> s a       -&gt; a
--   (<a>^.</a>) ::             s -&gt; <a>Lens'</a> s a      -&gt; a
--   (<a>^.</a>) :: <a>Monoid</a> m =&gt; s -&gt; <a>Traversal'</a> s m -&gt; m
--   </pre>
(^.) :: s -> Getting a s a -> a

-- | Replace the target of a <a>Lens</a> or all of the targets of a
--   <a>Setter</a> or <a>Traversal</a> with a constant value.
--   
--   This is an infix version of <a>set</a>, provided for consistency with
--   (<a>.=</a>).
--   
--   <pre>
--   f <a>&lt;$</a> a ≡ <a>mapped</a> <a>.~</a> f <a>$</a> a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b,c,d) &amp; _4 .~ e
--   (a,b,c,e)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (42,"world") &amp; _1 .~ "hello"
--   ("hello","world")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; both .~ c
--   (c,c)
--   </pre>
--   
--   <pre>
--   (<a>.~</a>) :: <a>Setter</a> s t a b    -&gt; b -&gt; s -&gt; t
--   (<a>.~</a>) :: <a>Iso</a> s t a b       -&gt; b -&gt; s -&gt; t
--   (<a>.~</a>) :: <a>Lens</a> s t a b      -&gt; b -&gt; s -&gt; t
--   (<a>.~</a>) :: <a>Traversal</a> s t a b -&gt; b -&gt; s -&gt; t
--   </pre>
(.~) :: ASetter s t a b -> b -> s -> t

-- | <pre>
--   type <a>Lens'</a> = <a>Simple</a> <a>Lens</a>
--   </pre>
type Lens' s a = Lens s s a a

-- | A <a>Getter</a> describes how to retrieve a single value in a way that
--   can be composed with other <a>LensLike</a> constructions.
--   
--   Unlike a <a>Lens</a> a <a>Getter</a> is read-only. Since a
--   <a>Getter</a> cannot be used to write back there are no <a>Lens</a>
--   laws that can be applied to it. In fact, it is isomorphic to an
--   arbitrary function from <tt>(s -&gt; a)</tt>.
--   
--   Moreover, a <a>Getter</a> can be used directly as a <a>Fold</a>, since
--   it just ignores the <a>Applicative</a>.
type Getter s a = forall (f :: * -> *). (Contravariant f, Functor f) => (a -> f a) -> s -> f s

-- | Build an (index-preserving) <a>Getter</a> from an arbitrary Haskell
--   function.
--   
--   <pre>
--   <a>to</a> f <a>.</a> <a>to</a> g ≡ <a>to</a> (g <a>.</a> f)
--   </pre>
--   
--   <pre>
--   a <a>^.</a> <a>to</a> f ≡ f a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; a ^.to f
--   f a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ("hello","world")^.to snd
--   "world"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 5^.to succ
--   6
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (0, -5)^._2.to abs
--   5
--   </pre>
--   
--   <pre>
--   <a>to</a> :: (s -&gt; a) -&gt; <a>IndexPreservingGetter</a> s a
--   </pre>
to :: (Profunctor p, Contravariant f) => (s -> a) -> Optic' * * p f s a

-- | Build a <a>Lens</a> from a getter and a setter.
--   
--   <pre>
--   <a>lens</a> :: <a>Functor</a> f =&gt; (s -&gt; a) -&gt; (s -&gt; b -&gt; t) -&gt; (a -&gt; f b) -&gt; s -&gt; f t
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; s ^. lens getter setter
--   getter s
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; s &amp; lens getter setter .~ b
--   setter s b
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; s &amp; lens getter setter %~ f
--   setter s (f (getter s))
--   </pre>
--   
--   <pre>
--   <a>lens</a> :: (s -&gt; a) -&gt; (s -&gt; a -&gt; s) -&gt; <a>Lens'</a> s a
--   </pre>
lens :: (s -> a) -> (s -> b -> t) -> Lens s t a b

-- | Conditional execution of <a>Applicative</a> expressions. For example,
--   
--   <pre>
--   when debug (putStrLn "Debugging")
--   </pre>
--   
--   will output the string <tt>Debugging</tt> if the Boolean value
--   <tt>debug</tt> is <a>True</a>, and otherwise do nothing.
when :: Applicative f => Bool -> f () -> f ()

-- | The reverse of <a>when</a>.
unless :: Applicative f => Bool -> f () -> f ()

-- | <a>forM</a> is <a>mapM</a> with its arguments flipped. For a version
--   that ignores the results see <a>forM_</a>.
forM :: (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)

-- | <a>forM_</a> is <a>mapM_</a> with its arguments flipped. For a version
--   that doesn't ignore the results see <a>forM</a>.
--   
--   As of base 4.8.0.0, <a>forM_</a> is just <a>for_</a>, specialized to
--   <a>Monad</a>.
forM_ :: (Foldable t, Monad m) => t a -> (a -> m b) -> m ()

-- | <tt><a>void</a> value</tt> discards or ignores the result of
--   evaluation, such as the return value of an <a>IO</a> action.
--   
--   <h4><b>Examples</b></h4>
--   
--   Replace the contents of a <tt><tt>Maybe</tt> <tt>Int</tt></tt> with
--   unit:
--   
--   <pre>
--   &gt;&gt;&gt; void Nothing
--   Nothing
--   
--   &gt;&gt;&gt; void (Just 3)
--   Just ()
--   </pre>
--   
--   Replace the contents of an <tt><tt>Either</tt> <tt>Int</tt>
--   <tt>Int</tt></tt> with unit, resulting in an <tt><tt>Either</tt>
--   <tt>Int</tt> '()'</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; void (Left 8675309)
--   Left 8675309
--   
--   &gt;&gt;&gt; void (Right 8675309)
--   Right ()
--   </pre>
--   
--   Replace every element of a list with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void [1,2,3]
--   [(),(),()]
--   </pre>
--   
--   Replace the second element of a pair with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void (1,2)
--   (1,())
--   </pre>
--   
--   Discard the result of an <a>IO</a> action:
--   
--   <pre>
--   &gt;&gt;&gt; mapM print [1,2]
--   1
--   2
--   [(),()]
--   
--   &gt;&gt;&gt; void $ mapM print [1,2]
--   1
--   2
--   </pre>
void :: Functor f => f a -> f ()

-- | <tt><a>replicateM</a> n act</tt> performs the action <tt>n</tt> times,
--   gathering the results.
replicateM :: Monad m => Int -> m a -> m [a]

-- | <tt><a>forever</a> act</tt> repeats the action infinitely.
forever :: Monad m => m a -> m b

-- | <tt><a>guard</a> b</tt> is <tt><a>pure</a> ()</tt> if <tt>b</tt> is
--   <a>True</a>, and <a>empty</a> if <tt>b</tt> is <a>False</a>.
guard :: Alternative f => Bool -> f ()

-- | Identity functor and monad. (a non-strict monad)
newtype Identity a :: * -> *
Identity :: a -> Identity a
[runIdentity] :: Identity a -> a

-- | Monads in which <a>IO</a> computations may be embedded. Any monad
--   built by applying a sequence of monad transformers to the <a>IO</a>
--   monad will be an instance of this class.
--   
--   Instances should satisfy the following laws, which state that
--   <a>liftIO</a> is a transformer of monads:
--   
--   <ul>
--   <li><pre><a>liftIO</a> . <a>return</a> = <a>return</a></pre></li>
--   <li><pre><a>liftIO</a> (m &gt;&gt;= f) = <a>liftIO</a> m &gt;&gt;=
--   (<a>liftIO</a> . f)</pre></li>
--   </ul>
class Monad m => MonadIO (m :: * -> *)

-- | Lift a computation from the <a>IO</a> monad.
liftIO :: MonadIO m => IO a -> m a

-- | An interface to random number generation monads.
class Monad m => MonadRandom (m :: * -> *)

-- | Return a randomly-selected value of type <tt>a</tt>. See <a>random</a>
--   for details.
getRandom :: (MonadRandom m, Random a) => m a

-- | Return a randomly-selected value of type <tt>a</tt> in the range
--   <i>[lo,hi]</i>. See <a>randomR</a> for details.
getRandomR :: (MonadRandom m, Random a) => (a, a) -> m a

-- | Return a randomly-selected value of type <tt>a</tt>. See <a>random</a>
--   for details.
getRandom :: MonadRandom m => forall a. Random a => m a

-- | Return a randomly-selected value of type <tt>a</tt> in the range
--   <i>[lo,hi]</i>. See <a>randomR</a> for details.
getRandomR :: MonadRandom m => forall a. Random a => (a, a) -> m a

-- | A monad transformer which adds a random number generator to an
--   existing monad.
data RandT g (m :: * -> *) a :: * -> (* -> *) -> * -> *

-- | Run a RandT computation using the generator <tt>g</tt>, returning the
--   result and the updated generator.
runRandT :: RandT g m a -> g -> m (a, g)

-- | Evaluate a RandT computation using the generator <tt>g</tt>. Note that
--   the generator <tt>g</tt> is not returned, so there's no way to recover
--   the updated version of <tt>g</tt>.
evalRandT :: Monad m => RandT g m a -> g -> m a

-- | The <a>StdGen</a> instance of <a>RandomGen</a> has a <a>genRange</a>
--   of at least 30 bits.
--   
--   The result of repeatedly using <a>next</a> should be at least as
--   statistically robust as the <i>Minimal Standard Random Number
--   Generator</i> described by [<a>System.Random\#Park</a>,
--   <a>System.Random\#Carta</a>]. Until more is known about
--   implementations of <a>split</a>, all we require is that <a>split</a>
--   deliver generators that are (a) not identical and (b) independently
--   robust in the sense just given.
--   
--   The <a>Show</a> and <a>Read</a> instances of <a>StdGen</a> provide a
--   primitive way to save the state of a random number generator. It is
--   required that <tt><a>read</a> (<a>show</a> g) == g</tt>.
--   
--   In addition, <a>reads</a> may be used to map an arbitrary string (not
--   necessarily one produced by <a>show</a>) onto a value of type
--   <a>StdGen</a>. In general, the <a>Read</a> instance of <a>StdGen</a>
--   has the following properties:
--   
--   <ul>
--   <li>It guarantees to succeed on any string.</li>
--   <li>It guarantees to consume only a finite portion of the string.</li>
--   <li>Different argument strings are likely to result in different
--   results.</li>
--   </ul>
data StdGen :: *

-- | The function <a>mkStdGen</a> provides an alternative way of producing
--   an initial generator, by mapping an <a>Int</a> into a generator.
--   Again, distinct arguments should be likely to produce distinct
--   generators.
mkStdGen :: Int -> StdGen

-- | Minimal definition is either both of <tt>get</tt> and <tt>put</tt> or
--   just <tt>state</tt>
class Monad m => MonadState s (m :: * -> *) | m -> s

-- | Return the state from the internals of the monad.
get :: MonadState s m => m s

-- | Replace the state inside the monad.
put :: MonadState s m => s -> m ()

-- | Embed a simple state action into the monad.
state :: MonadState s m => (s -> (a, s)) -> m a

-- | Lift a computation from the argument monad to the constructed monad.
lift :: MonadTrans t => forall (m :: * -> *) a. Monad m => m a -> t m a

-- | A state monad parameterized by the type <tt>s</tt> of the state to
--   carry.
--   
--   The <a>return</a> function leaves the state unchanged, while
--   <tt>&gt;&gt;=</tt> uses the final state of the first computation as
--   the initial state of the second.
type State s = StateT s Identity

-- | A state transformer monad parameterized by:
--   
--   <ul>
--   <li><tt>s</tt> - The state.</li>
--   <li><tt>m</tt> - The inner monad.</li>
--   </ul>
--   
--   The <a>return</a> function leaves the state unchanged, while
--   <tt>&gt;&gt;=</tt> uses the final state of the first computation as
--   the initial state of the second.
data StateT s (m :: * -> *) a :: * -> (* -> *) -> * -> *

-- | <tt><a>modify</a> f</tt> is an action that updates the state to the
--   result of applying <tt>f</tt> to the current state.
--   
--   <ul>
--   <li><pre><a>modify</a> f = <a>get</a> &gt;&gt;= (<a>put</a> .
--   f)</pre></li>
--   </ul>
modify :: Monad m => (s -> s) -> StateT s m ()

-- | Unwrap a state monad computation as a function. (The inverse of
--   <a>state</a>.)
runState :: State s a -> s -> (a, s)

-- | Evaluate a state computation with the given initial state and return
--   the final value, discarding the final state.
--   
--   <ul>
--   <li><pre><a>evalState</a> m s = <a>fst</a> (<a>runState</a> m
--   s)</pre></li>
--   </ul>
evalState :: State s a -> s -> a

-- | Evaluate a state computation with the given initial state and return
--   the final state, discarding the final value.
--   
--   <ul>
--   <li><pre><a>execState</a> m s = <a>snd</a> (<a>runState</a> m
--   s)</pre></li>
--   </ul>
execState :: State s a -> s -> s
runStateT :: StateT s m a -> s -> m (a, s)

-- | Evaluate a state computation with the given initial state and return
--   the final value, discarding the final state.
--   
--   <ul>
--   <li><pre><a>evalStateT</a> m s = <a>liftM</a> <a>fst</a>
--   (<a>runStateT</a> m s)</pre></li>
--   </ul>
evalStateT :: Monad m => StateT s m a -> s -> m a

-- | Evaluate a state computation with the given initial state and return
--   the final state, discarding the final value.
--   
--   <ul>
--   <li><pre><a>execStateT</a> m s = <a>liftM</a> <a>snd</a>
--   (<a>runStateT</a> m s)</pre></li>
--   </ul>
execStateT :: Monad m => StateT s m a -> s -> m s

-- | A writer monad parameterized by the type <tt>w</tt> of output to
--   accumulate.
--   
--   The <a>return</a> function produces the output <a>mempty</a>, while
--   <tt>&gt;&gt;=</tt> combines the outputs of the subcomputations using
--   <a>mappend</a>.
type Writer w = WriterT w Identity

-- | A writer monad parameterized by:
--   
--   <ul>
--   <li><tt>w</tt> - the output to accumulate.</li>
--   <li><tt>m</tt> - The inner monad.</li>
--   </ul>
--   
--   The <a>return</a> function produces the output <a>mempty</a>, while
--   <tt>&gt;&gt;=</tt> combines the outputs of the subcomputations using
--   <a>mappend</a>.
data WriterT w (m :: * -> *) a :: * -> (* -> *) -> * -> *

-- | <tt><a>tell</a> w</tt> is an action that produces the output
--   <tt>w</tt>.
tell :: (Monoid w, Monad m) => w -> WriterT w m ()

-- | Unwrap a writer computation as a (result, output) pair. (The inverse
--   of <a>writer</a>.)
runWriter :: Writer w a -> (a, w)

-- | Extract the output from a writer computation.
--   
--   <ul>
--   <li><pre><a>execWriter</a> m = <a>snd</a> (<a>runWriter</a>
--   m)</pre></li>
--   </ul>
execWriter :: Writer w a -> w
runWriterT :: WriterT w m a -> m (a, w)

-- | Extract the output from a writer computation.
--   
--   <ul>
--   <li><pre><a>execWriterT</a> m = <a>liftM</a> <a>snd</a>
--   (<a>runWriterT</a> m)</pre></li>
--   </ul>
execWriterT :: Monad m => WriterT w m a -> m w

-- | Extracts from a list of <a>Either</a> all the <a>Left</a> elements.
--   All the <a>Left</a> elements are extracted in order.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; let list = [ Left "foo", Right 3, Left "bar", Right 7, Left "baz" ]
--   
--   &gt;&gt;&gt; lefts list
--   ["foo","bar","baz"]
--   </pre>
lefts :: [Either a b] -> [a]

-- | Extracts from a list of <a>Either</a> all the <a>Right</a> elements.
--   All the <a>Right</a> elements are extracted in order.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; let list = [ Left "foo", Right 3, Left "bar", Right 7, Left "baz" ]
--   
--   &gt;&gt;&gt; rights list
--   [3,7]
--   </pre>
rights :: [Either a b] -> [b]

-- | List of elements of a structure, from left to right.
toList :: Foldable t => forall a. t a -> [a]

-- | <tt>(*) `on` f = \x y -&gt; f x * f y</tt>.
--   
--   Typical usage: <tt><a>sortBy</a> (<tt>compare</tt> `on`
--   <tt>fst</tt>)</tt>.
--   
--   Algebraic properties:
--   
--   <ul>
--   <li><tt>(*) `on` <a>id</a> = (*)</tt> (if <tt>(*) ∉ {⊥, <a>const</a>
--   ⊥}</tt>)</li>
--   <li><pre>((*) `on` f) `on` g = (*) `on` (f . g)</pre></li>
--   <li><pre><a>flip</a> on f . <a>flip</a> on g = <a>flip</a> on (g .
--   f)</pre></li>
--   </ul>
on :: (b -> b -> c) -> (a -> b) -> a -> a -> c

-- | The <a>sort</a> function implements a stable sorting algorithm. It is
--   a special case of <a>sortBy</a>, which allows the programmer to supply
--   their own comparison function.
sort :: Ord a => [a] -> [a]

-- | The <a>sortBy</a> function is the non-overloaded version of
--   <a>sort</a>.
sortBy :: (a -> a -> Ordering) -> [a] -> [a]

-- | The least element of a non-empty structure with respect to the given
--   comparison function.
minimumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a

-- | The largest element of a non-empty structure with respect to the given
--   comparison function.
maximumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a

-- | Left-associative fold of a structure. but with strict application of
--   the operator.
--   
--   <pre>
--   <a>foldl</a> f z = <a>foldl'</a> f z . <a>toList</a>
--   </pre>
foldl' :: Foldable t => forall b a. (b -> a -> b) -> b -> t a -> b

-- | <a>intercalate</a> <tt>xs xss</tt> is equivalent to <tt>(<a>concat</a>
--   (<a>intersperse</a> xs xss))</tt>. It inserts the list <tt>xs</tt> in
--   between the lists in <tt>xss</tt> and concatenates the result.
intercalate :: [a] -> [[a]] -> [a]

-- | The <a>catMaybes</a> function takes a list of <a>Maybe</a>s and
--   returns a list of all the <a>Just</a> values.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; catMaybes [Just 1, Nothing, Just 3]
--   [1,3]
--   </pre>
--   
--   When constructing a list of <a>Maybe</a> values, <a>catMaybes</a> can
--   be used to return all of the "success" results (if the list is the
--   result of a <a>map</a>, then <a>mapMaybe</a> would be more
--   appropriate):
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; [readMaybe x :: Maybe Int | x &lt;- ["1", "Foo", "3"] ]
--   [Just 1,Nothing,Just 3]
--   
--   &gt;&gt;&gt; catMaybes $ [readMaybe x :: Maybe Int | x &lt;- ["1", "Foo", "3"] ]
--   [1,3]
--   </pre>
catMaybes :: [Maybe a] -> [a]

-- | The <a>fromJust</a> function extracts the element out of a <a>Just</a>
--   and throws an error if its argument is <a>Nothing</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; fromJust (Just 1)
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 2 * (fromJust (Just 10))
--   20
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 2 * (fromJust Nothing)
--   *** Exception: Maybe.fromJust: Nothing
--   </pre>
fromJust :: Maybe a -> a

-- | The <a>fromMaybe</a> function takes a default value and and
--   <a>Maybe</a> value. If the <a>Maybe</a> is <a>Nothing</a>, it returns
--   the default values; otherwise, it returns the value contained in the
--   <a>Maybe</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; fromMaybe "" (Just "Hello, World!")
--   "Hello, World!"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromMaybe "" Nothing
--   ""
--   </pre>
--   
--   Read an integer from a string using <tt>readMaybe</tt>. If we fail to
--   parse an integer, we want to return <tt>0</tt> by default:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; fromMaybe 0 (readMaybe "5")
--   5
--   
--   &gt;&gt;&gt; fromMaybe 0 (readMaybe "")
--   0
--   </pre>
fromMaybe :: a -> Maybe a -> a

-- | An infix synonym for <a>mappend</a>.
(<>) :: Monoid m => m -> m -> m

-- | <tt><a>getDirectoryContents</a> dir</tt> returns a list of <i>all</i>
--   entries in <i>dir</i>.
--   
--   The operation may fail with:
--   
--   <ul>
--   <li><tt>HardwareFault</tt> A physical I/O error has occurred.
--   <tt>[EIO]</tt></li>
--   <li><tt>InvalidArgument</tt> The operand is not a valid directory
--   name. <tt>[ENAMETOOLONG, ELOOP]</tt></li>
--   <li><a>isDoesNotExistError</a> / <tt>NoSuchThing</tt> The directory
--   does not exist. <tt>[ENOENT, ENOTDIR]</tt></li>
--   <li><a>isPermissionError</a> / <tt>PermissionDenied</tt> The process
--   has insufficient privileges to perform the operation.
--   <tt>[EACCES]</tt></li>
--   <li><tt>ResourceExhausted</tt> Insufficient resources are available to
--   perform the operation. <tt>[EMFILE, ENFILE]</tt></li>
--   <li><a>InappropriateType</a> The path refers to an existing
--   non-directory object. <tt>[ENOTDIR]</tt></li>
--   </ul>
getDirectoryContents :: FilePath -> IO [FilePath]

-- | Computation <a>getArgs</a> returns a list of the program's command
--   line arguments (not including the program name).
getArgs :: IO [String]

-- | Join two values with a path separator. For examples and caveats see
--   the equivalent function <a>combine</a>.
--   
--   <pre>
--   Posix:   "/directory" &lt;/&gt; "file.ext" == "/directory/file.ext"
--   Windows: "/directory" &lt;/&gt; "file.ext" == "/directory\\file.ext"
--   </pre>
(</>) :: FilePath -> FilePath -> FilePath

-- | Add an extension, even if there is already one there, equivalent to
--   <a>addExtension</a>.
--   
--   <pre>
--   "/directory/path" &lt;.&gt; "ext" == "/directory/path.ext"
--   "/directory/path" &lt;.&gt; ".ext" == "/directory/path.ext"
--   </pre>
(<.>) :: FilePath -> String -> FilePath

-- | <tt><a>withFile</a> name mode act</tt> opens a file using
--   <a>openFile</a> and passes the resulting handle to the computation
--   <tt>act</tt>. The handle will be closed on exit from <a>withFile</a>,
--   whether by normal termination or by raising an exception. If closing
--   the handle raises an exception, then this exception will be raised by
--   <a>withFile</a> rather than any exception raised by <tt>act</tt>.
withFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r

-- | See <a>openFile</a>
data IOMode :: *
ReadMode :: IOMode
WriteMode :: IOMode
AppendMode :: IOMode
ReadWriteMode :: IOMode

-- | Computation <a>hPutStr</a> <tt>hdl s</tt> writes the string <tt>s</tt>
--   to the file or channel managed by <tt>hdl</tt>.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isFullError</a> if the device is full; or</li>
--   <li><a>isPermissionError</a> if another system resource limit would be
--   exceeded.</li>
--   </ul>
hPutStr :: Handle -> String -> IO ()

-- | The same as <a>hPutStr</a>, but adds a newline character.
hPutStrLn :: Handle -> String -> IO ()

-- | Format a variable number of arguments with the C-style formatting
--   string. The return value is either <a>String</a> or <tt>(<a>IO</a>
--   a)</tt> (which should be <tt>(<a>IO</a> '()')</tt>, but Haskell's type
--   system makes this hard).
--   
--   The format string consists of ordinary characters and <i>conversion
--   specifications</i>, which specify how to format one of the arguments
--   to <a>printf</a> in the output string. A format specification is
--   introduced by the <tt>%</tt> character; this character can be
--   self-escaped into the format string using <tt>%%</tt>. A format
--   specification ends with a /format character/ that provides the primary
--   information about how to format the value. The rest of the conversion
--   specification is optional. In order, one may have flag characters, a
--   width specifier, a precision specifier, and type-specific modifier
--   characters.
--   
--   Unlike C <tt>printf(3)</tt>, the formatting of this <a>printf</a> is
--   driven by the argument type; formatting is type specific. The types
--   formatted by <a>printf</a> "out of the box" are:
--   
--   <ul>
--   <li><a>Integral</a> types, including <a>Char</a></li>
--   <li><a>String</a></li>
--   <li><a>RealFloat</a> types</li>
--   </ul>
--   
--   <a>printf</a> is also extensible to support other types: see below.
--   
--   A conversion specification begins with the character <tt>%</tt>,
--   followed by zero or more of the following flags:
--   
--   <pre>
--   -      left adjust (default is right adjust)
--   +      always use a sign (+ or -) for signed conversions
--   space  leading space for positive numbers in signed conversions
--   0      pad with zeros rather than spaces
--   #      use an \"alternate form\": see below
--   </pre>
--   
--   When both flags are given, <tt>-</tt> overrides <tt>0</tt> and
--   <tt>+</tt> overrides space. A negative width specifier in a <tt>*</tt>
--   conversion is treated as positive but implies the left adjust flag.
--   
--   The "alternate form" for unsigned radix conversions is as in C
--   <tt>printf(3)</tt>:
--   
--   <pre>
--   %o           prefix with a leading 0 if needed
--   %x           prefix with a leading 0x if nonzero
--   %X           prefix with a leading 0X if nonzero
--   %b           prefix with a leading 0b if nonzero
--   %[eEfFgG]    ensure that the number contains a decimal point
--   </pre>
--   
--   Any flags are followed optionally by a field width:
--   
--   <pre>
--   num    field width
--   *      as num, but taken from argument list
--   </pre>
--   
--   The field width is a minimum, not a maximum: it will be expanded as
--   needed to avoid mutilating a value.
--   
--   Any field width is followed optionally by a precision:
--   
--   <pre>
--   .num   precision
--   .      same as .0
--   .*     as num, but taken from argument list
--   </pre>
--   
--   Negative precision is taken as 0. The meaning of the precision depends
--   on the conversion type.
--   
--   <pre>
--   Integral    minimum number of digits to show
--   RealFloat   number of digits after the decimal point
--   String      maximum number of characters
--   </pre>
--   
--   The precision for Integral types is accomplished by zero-padding. If
--   both precision and zero-pad are given for an Integral field, the
--   zero-pad is ignored.
--   
--   Any precision is followed optionally for Integral types by a width
--   modifier; the only use of this modifier being to set the implicit size
--   of the operand for conversion of a negative operand to unsigned:
--   
--   <pre>
--   hh     Int8
--   h      Int16
--   l      Int32
--   ll     Int64
--   L      Int64
--   </pre>
--   
--   The specification ends with a format character:
--   
--   <pre>
--   c      character               Integral
--   d      decimal                 Integral
--   o      octal                   Integral
--   x      hexadecimal             Integral
--   X      hexadecimal             Integral
--   b      binary                  Integral
--   u      unsigned decimal        Integral
--   f      floating point          RealFloat
--   F      floating point          RealFloat
--   g      general format float    RealFloat
--   G      general format float    RealFloat
--   e      exponent format float   RealFloat
--   E      exponent format float   RealFloat
--   s      string                  String
--   v      default format          any type
--   </pre>
--   
--   The "%v" specifier is provided for all built-in types, and should be
--   provided for user-defined type formatters as well. It picks a "best"
--   representation for the given type. For the built-in types the "%v"
--   specifier is converted as follows:
--   
--   <pre>
--   c      Char
--   u      other unsigned Integral
--   d      other signed Integral
--   g      RealFloat
--   s      String
--   </pre>
--   
--   Mismatch between the argument types and the format string, as well as
--   any other syntactic or semantic errors in the format string, will
--   cause an exception to be thrown at runtime.
--   
--   Note that the formatting for <a>RealFloat</a> types is currently a bit
--   different from that of C <tt>printf(3)</tt>, conforming instead to
--   <a>showEFloat</a>, <a>showFFloat</a> and <a>showGFloat</a> (and their
--   alternate versions <a>showFFloatAlt</a> and <a>showGFloatAlt</a>).
--   This is hard to fix: the fixed versions would format in a
--   backward-incompatible way. In any case the Haskell behavior is
--   generally more sensible than the C behavior. A brief summary of some
--   key differences:
--   
--   <ul>
--   <li>Haskell <a>printf</a> never uses the default "6-digit" precision
--   used by C printf.</li>
--   <li>Haskell <a>printf</a> treats the "precision" specifier as
--   indicating the number of digits after the decimal point.</li>
--   <li>Haskell <a>printf</a> prints the exponent of e-format numbers
--   without a gratuitous plus sign, and with the minimum possible number
--   of digits.</li>
--   <li>Haskell <a>printf</a> will place a zero after a decimal point when
--   possible.</li>
--   </ul>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt; printf "%d\n" (23::Int)
--   23
--   &gt; printf "%s %s\n" "Hello" "World"
--   Hello World
--   &gt; printf "%.2f\n" pi
--   3.14
--   </pre>
printf :: PrintfType r => String -> r


-- | This module defines fixed-length <i>vectors</i> and some basic
--   typeclass instances and operations for them.
module Data.Utils.Vector

-- | <tt><a>Vector</a> n a</tt> is the type of vectors of length <tt>n</tt>
--   with elements of type <tt>a</tt>.
data Vector :: Nat -> * -> *

-- | The <i>scalar product</i> of two vectors of the same length.
--   
--   <pre>
--   &gt;&gt;&gt; :set -XDataKinds
--   
--   &gt;&gt;&gt; cons 1 (cons 2 nil) &lt;%&gt; cons 3 (cons 4 nil) :: Int
--   11
--   </pre>
(<%>) :: Num a => Vector n a -> Vector n a -> a

-- | The vector of length zero.
nil :: Vector 0 a

-- | Prepends the specified element to the specified vector.
--   
--   <pre>
--   &gt;&gt;&gt; cons False (cons True nil)
--   [False,True]
--   </pre>
cons :: a -> Vector n a -> Vector (n + 1) a

-- | Generates a vector by applying the given function to each index.
--   
--   <pre>
--   &gt;&gt;&gt; :set -XDataKinds
--   
--   &gt;&gt;&gt; generate id :: Vector 3 Int
--   [0,1,2]
--   </pre>
generate :: KnownNat n => (Int -> a) -> Vector n a

-- | Gets the vector element at the specified index if the index is valid,
--   otherwise <a>Nothing</a>.
--   
--   <pre>
--   &gt;&gt;&gt; cons 'x' nil !? 0
--   Just 'x'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; cons 'x' nil !? 1
--   Nothing
--   </pre>
(!?) :: Vector n a -> Int -> Maybe a

-- | Gets the vector element at the specified index, throws an exception if
--   the index is invalid.
--   
--   <pre>
--   &gt;&gt;&gt; cons 'x' nil ! 0
--   'x'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; cons 'x' nil ! 1
--   *** Exception: Data.Utils.Vector.!: invalid index 
--   </pre>
(!) :: Vector n a -> Int -> a

-- | Gets the first element of a vector of length greater than zero.
--   
--   <pre>
--   &gt;&gt;&gt; vhead (cons 'x' (cons 'y' nil))
--   'x'
--   </pre>
vhead :: (1 <= n) => Vector n a -> a

-- | For a vector of length greater than zero, gets the vector with its
--   first element removed.
--   
--   <pre>
--   &gt;&gt;&gt; vtail (cons 'x' (cons 'y' nil))
--   "y"
--   </pre>
vtail :: (1 <= n) => Vector n a -> Vector (n - 1) a

-- | Adds two vectors of the same length.
--   
--   <pre>
--   &gt;&gt;&gt; :set -XDataKinds
--   
--   &gt;&gt;&gt; (cons 1 (cons 2 nil)) &lt;+&gt; (cons 3 (cons 4 nil)) :: Vector 2 Int
--   [4,6]
--   </pre>
(<+>) :: (Num a, KnownNat n) => Vector n a -> Vector n a -> Vector n a

-- | Subtracts two vectors of the same length.
--   
--   <pre>
--   &gt;&gt;&gt; :set -XDataKinds
--   
--   &gt;&gt;&gt; (cons 1 (cons 2 nil)) &lt;-&gt; (cons 3 (cons 4 nil)) :: Vector 2 Int
--   [-2,-2]
--   </pre>
(<->) :: (Num a, KnownNat n) => Vector n a -> Vector n a -> Vector n a

-- | Calculates the <i>squared</i> euclidean norm of a vector, i.e. the
--   scalar product of the vector by itself.
--   
--   <pre>
--   &gt;&gt;&gt; :set -XDataKinds
--   
--   &gt;&gt;&gt; sqNorm (cons 3 (cons 4 nil)) :: Int
--   25
--   </pre>
sqNorm :: (Num a, KnownNat n) => Vector n a -> a

-- | Calculates the <i>squared</i> euclidean distance between two vectors
--   of the same length.
--   
--   <pre>
--   &gt;&gt;&gt; :set -XDataKinds
--   
--   &gt;&gt;&gt; sqDiff (cons 1 (cons 2 nil)) (cons 3 (cons 4 nil)) :: Int
--   8
--   </pre>
sqDiff :: (Num a, KnownNat n) => Vector n a -> Vector n a -> a

-- | This class gives the integer associated with a type-level natural.
--   There are instances of the class for every concrete literal: 0, 1, 2,
--   etc.
class KnownNat (n :: Nat)

natVal :: KnownNat n => proxy n -> Integer
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Utils.Vector.Vector n a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Utils.Vector.Vector n a)
instance GHC.Base.Functor (Data.Utils.Vector.Vector n)
instance GHC.TypeLits.KnownNat n => GHC.Base.Applicative (Data.Utils.Vector.Vector n)
instance Data.Foldable.Foldable (Data.Utils.Vector.Vector n)
instance Data.Traversable.Traversable (Data.Utils.Vector.Vector n)
instance (GHC.TypeLits.KnownNat n, GHC.Read.Read a) => GHC.Read.Read (Data.Utils.Vector.Vector n a)


-- | This module defines fixed-size <i>matrices</i> and some basic
--   typeclass instances and operations for them.
module Data.Utils.Matrix

-- | <tt><a>Matrix</a> m n a</tt> is the type of <i>matrices</i> with
--   <tt>m</tt> rows, <tt>n</tt> columns and entries of type <tt>a</tt>.
newtype Matrix (m :: Nat) (n :: Nat) a
Matrix :: (Vector m (Vector n a)) -> Matrix a

-- | Multiplication of a <i>matrix</i> by a (column-)<i>vector</i>.
--   
--   <pre>
--   &gt;&gt;&gt; :set -XDataKinds
--   
--   &gt;&gt;&gt; (pure 1 :: Matrix 1 2 Int) &lt;%%&gt; cons 1 (cons 2 nil)
--   [3]
--   </pre>
(<%%>) :: Num a => Matrix m n a -> Vector n a -> Vector m a

-- | Gives the matrix row with the specified index (starting at zero) if
--   the index is valid, otherwise <a>Nothing</a>.
--   
--   <pre>
--   &gt;&gt;&gt; :set -XDataKinds
--   
--   &gt;&gt;&gt; row (pure 42 :: Matrix 2 4 Int) 0
--   Just [42,42,42,42]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; row (pure 42 :: Matrix 2 4 Int) 2
--   Nothing
--   </pre>
row :: Matrix m n a -> Int -> Maybe (Vector n a)

-- | Gives the matrix column with the specified index (starting at zero) if
--   the index is valid, otherwise <a>Nothing</a>.
--   
--   <pre>
--   &gt;&gt;&gt; :set -XDataKinds
--   
--   &gt;&gt;&gt; column (pure 42 :: Matrix 2 4 Int) 3
--   Just [42,42]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; column (pure 42 :: Matrix 2 4 Int) 4
--   Nothing
--   </pre>
column :: Matrix m n a -> Int -> Maybe (Vector m a)

-- | Generates a matrix by applying the given function to each index (row,
--   column).
--   
--   <pre>
--   &gt;&gt;&gt; :set -XDataKinds
--   
--   &gt;&gt;&gt; mgenerate id :: Matrix 3 2 (Int, Int)
--   Matrix [[(0,0),(0,1)],[(1,0),(1,1)],[(2,0),(2,1)]]
--   </pre>
mgenerate :: (KnownNat m, KnownNat n) => ((Int, Int) -> a) -> Matrix m n a

-- | Gives the matrix element with the specified index (row, column) if the
--   index is valid, otherwise <a>Nothing</a>.
--   
--   <pre>
--   &gt;&gt;&gt; :set -XDataKinds
--   
--   &gt;&gt;&gt; let m = mgenerate (uncurry (+)) :: Matrix 2 3 Int
--   
--   &gt;&gt;&gt; m !!? (0,0)
--   Just 0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; m !!? (1, 2)
--   Just 3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; m !!? (5, 7)
--   Nothing
--   </pre>
(!!?) :: Matrix m n a -> (Int, Int) -> Maybe a

-- | Transposes a matrix.
--   
--   <pre>
--   &gt;&gt;&gt; transpose (Matrix $ cons (cons 'a' nil) (cons (cons 'b' nil) nil))
--   Matrix ["ab"]
--   </pre>
transpose :: (KnownNat m, KnownNat n) => Matrix m n a -> Matrix n m a
instance Data.Traversable.Traversable (Data.Utils.Matrix.Matrix m n)
instance Data.Foldable.Foldable (Data.Utils.Matrix.Matrix m n)
instance GHC.Base.Functor (Data.Utils.Matrix.Matrix m n)
instance GHC.Show.Show a => GHC.Show.Show (Data.Utils.Matrix.Matrix m n a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Utils.Matrix.Matrix m n a)
instance (GHC.TypeLits.KnownNat m, GHC.TypeLits.KnownNat n) => GHC.Base.Applicative (Data.Utils.Matrix.Matrix m n)


-- | This module defines the <a>StackT</a> monad transformer, which is
--   simply a wrapped state monad whose state is a list.
module Data.Utils.Stack

-- | A computation of type <tt><a>StackT</a> s m a</tt> has access to a
--   stack of elements of type <tt>s</tt>.
data StackT s m a

-- | Pops the top element from the stack. Returns <a>Nothing</a> if the
--   stack is empty.
pop :: Monad m => StackT s m (Maybe s)

-- | Peeks at the top element of the stack. Returns <a>Nothing</a> if the
--   stack is empty.
peek :: Monad m => StackT s m (Maybe s)

-- | Pushes a new element onto the stack.
push :: Monad m => s -> StackT s m ()

-- | Runs a computation in the <tt><a>StackT</a> s m</tt> monad.
runStackT :: Monad m => StackT s m a -> [s] -> m (a, [s])

-- | Evaluates a computation in the <tt><a>StackT</a> s m</tt> monad.
evalStackT :: Monad m => StackT s m a -> [s] -> m a

-- | Executes a computation in the <tt><a>StackT</a> s m</tt> monad.
execStackT :: Monad m => StackT s m a -> [s] -> m [s]

-- | A pure stack monad.
type Stack s = StackT s Identity

-- | Runs a computation in the <tt><a>Stack</a> s</tt> monad.
runStack :: Stack s a -> [s] -> (a, [s])

-- | Evaluates a computation in the <tt><a>Stack</a> s</tt> monad.
evalStack :: Stack s a -> [s] -> a

-- | Executes a computation in the <tt><a>Stack</a> s</tt> monad.
execStack :: Stack s a -> [s] -> [s]
instance Control.Monad.Trans.Class.MonadTrans (Data.Utils.Stack.StackT s)
instance GHC.Base.Monad m => GHC.Base.Monad (Data.Utils.Stack.StackT s m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Data.Utils.Stack.StackT s m)
instance GHC.Base.Functor m => GHC.Base.Functor (Data.Utils.Stack.StackT s m)


-- | This module contains utility functions related to the
--   <a>Traversable</a> typeclass.
module Data.Utils.Traversable

-- | Tries to create a traversable (which must also be applicative) from a
--   list. If the list contains too few elements, <a>Nothing</a> is
--   returned,
--   
--   <pre>
--   &gt;&gt;&gt; fromList [1, 2, 3] :: Maybe (Identity Int)
--   Just (Identity 1)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromList [] :: Maybe (Identity Char)
--   Nothing
--   </pre>
fromList :: (Applicative t, Traversable t) => [a] -> Maybe (t a)

-- | Returns the head of a non-empty list or <a>Nothing</a> for the empty
--   list.
--   
--   <pre>
--   &gt;&gt;&gt; safeHead "Haskell"
--   Just 'H'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; safeHead ""
--   Nothing
--   </pre>
safeHead :: [a] -> Maybe a


-- | This module reexports various utility modules for convenience.
module Data.Utils


-- | This modules provides utilities for data normalization.
module Numeric.Neural.Normalization

-- | Provides "1 of <tt>n</tt>" encoding for enumerable types.
--   
--   <pre>
--   &gt;&gt;&gt; :set -XDataKinds
--   
--   &gt;&gt;&gt; encode1ofN LT :: Vector 3 Int
--   [1,0,0]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; encode1ofN EQ :: Vector 3 Int
--   [0,1,0]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; encode1ofN GT :: Vector 3 Int
--   [0,0,1]
--   </pre>
encode1ofN :: (Enum a, Num b, KnownNat n) => a -> Vector n b

-- | Provides "1 of <tt>n</tt>" decoding for enumerable types.
--   
--   <pre>
--   &gt;&gt;&gt; decode1ofN [0.9, 0.3, 0.1 :: Double] :: Ordering
--   LT
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; decode1ofN [0.7, 0.8, 0.6 :: Double] :: Ordering
--   EQ
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; decode1ofN [0.2, 0.3, 0.8 :: Double] :: Ordering
--   GT
--   </pre>
decode1ofN :: (Enum a, Num b, Ord b, Foldable f) => f b -> a

-- | Provides equidistant encoding for enumerable types.
--   
--   <pre>
--   &gt;&gt;&gt; :set -XDataKinds
--   
--   &gt;&gt;&gt; encodeEquiDist LT :: Vector 2 Float
--   [1.0,0.0]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; encodeEquiDist EQ :: Vector 2 Float
--   [-0.5,-0.86602545]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; encodeEquiDist GT :: Vector 2 Float
--   [-0.5,0.86602545]
--   </pre>
encodeEquiDist :: (Enum a, Floating b, KnownNat n) => a -> Vector n b

-- | Provides equidistant decoding for enumerable types.
--   
--   <pre>
--   &gt;&gt;&gt; :set -XDataKinds
--   
--   &gt;&gt;&gt; let u = fromJust (fromList [0.9, 0.2]) :: Vector 2 Double
--   
--   &gt;&gt;&gt; decodeEquiDist u :: Ordering
--   LT
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :set -XDataKinds
--   
--   &gt;&gt;&gt; let v = fromJust (fromList [-0.4, -0.5]) :: Vector 2 Double
--   
--   &gt;&gt;&gt; decodeEquiDist v :: Ordering
--   EQ
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :set -XDataKinds
--   
--   &gt;&gt;&gt; let w = fromJust (fromList [0.1, 0.8]) :: Vector 2 Double
--   
--   &gt;&gt;&gt; decodeEquiDist w :: Ordering
--   GT
--   </pre>
decodeEquiDist :: (Enum a, Ord b, Floating b, KnownNat n) => Vector n b -> a

-- | Computes the cross entropy error (assuming "1 of n" encoding).
--   
--   <pre>
--   &gt;&gt;&gt; crossEntropyError LT (cons 0.8 (cons 0.1 (cons 0.1 nil))) :: Float
--   0.22314353
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; crossEntropyError EQ (cons 0.8 (cons 0.1 (cons 0.1 nil))) :: Float
--   2.3025851 
--   </pre>
crossEntropyError :: (Enum a, Floating b, KnownNat n) => a -> Vector n b -> b


-- | This module defines <i>parameterized functions</i>, <i>components</i>
--   and <i>models</i>. The parameterized functions and components are
--   instances of the <a>Arrow</a> typeclass and can therefore be combined
--   easily and flexibly.
--   
--   <i>Models</i> contain a component, can measure their error with regard
--   to samples and can be trained by gradient descent/ backpropagation.
module Numeric.Neural.Model

-- | The type <tt><a>ParamFun</a> t a b</tt> describes parameterized
--   functions from <tt>a</tt> to <tt>b</tt>, where the parameters are of
--   type <tt>t <a>Analytic</a></tt>. When such components are composed,
--   they all share the <i>same</i> parameters.
newtype ParamFun t a b
ParamFun :: (a -> t Analytic -> b) -> ParamFun t a b
[runPF] :: ParamFun t a b -> a -> t Analytic -> b

-- | A <tt><a>Model</a> a b</tt> is a parameterized function from
--   <tt>a</tt> to <tt>b</tt>, combined with <i>some</i> collection of
--   analytic parameters, In contrast to <a>ParamFun</a>, when components
--   are composed, parameters are not shared. Each component carries its
--   own collection of parameters instead.
data Component a b
Component :: t Double -> ParamFun t a b -> (forall m. MonadRandom m => m (t Double)) -> Component a b

-- | the specific parameter values
[weights] :: Component a b -> t Double

-- | the encapsulated parameterized function
[compute] :: Component a b -> ParamFun t a b

-- | randomly sets the parameters
[initR] :: Component a b -> forall m. MonadRandom m => m (t Double)

-- | A <a>Lens'</a> to get or set the weights of a component. The shape of
--   the parameter collection is hidden by existential quantification, so
--   this lens has to use simple generic lists.
weightsLens :: Lens' (Component a b) [Double]

-- | Activates a component, i.e. applies it to the specified input, using
--   the current parameter values.
activate :: Component a b -> a -> b

-- | A <tt><a>Model</a> f g a b c</tt> wraps a <tt><a>Component</a> (f
--   <a>Analytic</a>) (g <a>Analytic</a>)</tt> and models functions <tt>b
--   -&gt; c</tt> with "samples" (for model error determination) of type
--   <tt>a</tt>.
data Model :: (* -> *) -> (* -> *) -> * -> * -> * -> *
Model :: Component (f Analytic) (g Analytic) -> (a -> (f Double, g Analytic -> Analytic)) -> (b -> f Double) -> (g Double -> c) -> Model f g a b c

-- | Computes the modelled function.
model :: Model f g a b c -> b -> c

-- | Generates a model with randomly initialized weights. All other
--   properties are copied from the provided model.
modelR :: MonadRandom m => Model f g a b c -> m (Model f g a b c)

-- | Calculates the avarage model error for a "mini-batch" of samples.
modelError :: Foldable h => Model f g a b c -> h a -> Double

-- | Performs one step of gradient descent/ backpropagation on the model,
descent :: (Foldable h) => Model f g a b c -> Double -> h a -> (Double, Model f g a b c)

-- | A type abbreviation for the most common type of models, where samples
--   are just input-output tuples.
type StdModel f g b c = Model f g (b, c) b c

-- | Creates a <a>StdModel</a>, using the simplifying assumtion that the
--   error can be computed from the expected output allone.
mkStdModel :: (Functor f, Functor g) => Component (f Analytic) (g Analytic) -> (c -> g Analytic -> Analytic) -> (b -> f Double) -> (g Double -> c) -> StdModel f g b c
instance (Data.Traversable.Traversable s, Data.Traversable.Traversable t) => Data.Traversable.Traversable (Numeric.Neural.Model.Pair s t)
instance (Data.Foldable.Foldable s, Data.Foldable.Foldable t) => Data.Foldable.Foldable (Numeric.Neural.Model.Pair s t)
instance (GHC.Base.Functor s, GHC.Base.Functor t) => GHC.Base.Functor (Numeric.Neural.Model.Pair s t)
instance (GHC.Classes.Ord (s a), GHC.Classes.Ord (t a)) => GHC.Classes.Ord (Numeric.Neural.Model.Pair s t a)
instance (GHC.Classes.Eq (s a), GHC.Classes.Eq (t a)) => GHC.Classes.Eq (Numeric.Neural.Model.Pair s t a)
instance (GHC.Read.Read (s a), GHC.Read.Read (t a)) => GHC.Read.Read (Numeric.Neural.Model.Pair s t a)
instance (GHC.Show.Show (s a), GHC.Show.Show (t a)) => GHC.Show.Show (Numeric.Neural.Model.Pair s t a)
instance Data.Traversable.Traversable Numeric.Neural.Model.Empty
instance Data.Foldable.Foldable Numeric.Neural.Model.Empty
instance GHC.Base.Functor Numeric.Neural.Model.Empty
instance GHC.Classes.Ord (Numeric.Neural.Model.Empty a)
instance GHC.Classes.Eq (Numeric.Neural.Model.Empty a)
instance GHC.Read.Read (Numeric.Neural.Model.Empty a)
instance GHC.Show.Show (Numeric.Neural.Model.Empty a)
instance Control.Category.Category (Numeric.Neural.Model.ParamFun t)
instance Control.Arrow.Arrow (Numeric.Neural.Model.ParamFun t)
instance Control.Arrow.ArrowChoice (Numeric.Neural.Model.ParamFun t)
instance Data.Utils.Arrow.ArrowConvolve (Numeric.Neural.Model.ParamFun t)
instance GHC.Base.Functor (Numeric.Neural.Model.ParamFun t a)
instance GHC.Base.Applicative (Numeric.Neural.Model.ParamFun t a)
instance Data.Profunctor.Unsafe.Profunctor (Numeric.Neural.Model.ParamFun t)
instance GHC.Base.Applicative Numeric.Neural.Model.Empty
instance (GHC.Base.Applicative s, GHC.Base.Applicative t) => GHC.Base.Applicative (Numeric.Neural.Model.Pair s t)
instance Control.Category.Category Numeric.Neural.Model.Component
instance Control.Arrow.Arrow Numeric.Neural.Model.Component
instance Control.Arrow.ArrowChoice Numeric.Neural.Model.Component
instance Data.Utils.Arrow.ArrowConvolve Numeric.Neural.Model.Component
instance GHC.Base.Functor (Numeric.Neural.Model.Component a)
instance GHC.Base.Applicative (Numeric.Neural.Model.Component a)
instance Data.Profunctor.Unsafe.Profunctor Numeric.Neural.Model.Component
instance Data.Profunctor.Unsafe.Profunctor (Numeric.Neural.Model.Model f g a)


-- | This modules provides a "pipes"-based API for working with models.
module Numeric.Neural.Pipes

-- | The training state of a model.
data TS f g a b c
TS :: Model f g a b c -> Int -> Double -> Double -> TS f g a b c

-- | updated model
[tsModel] :: TS f g a b c -> Model f g a b c

-- | generation
[tsGeneration] :: TS f g a b c -> Int

-- | learning rate
[tsEta] :: TS f g a b c -> Double

-- | last training error
[tsBatchError] :: TS f g a b c -> Double

-- | A <a>Pipe</a> for training a model: It consumes mini-batches of
--   samples from upstream and pushes the updated training state
--   downstream.
descentP :: (Foldable h, Monad m) => Model f g a b c -> Int -> (Int -> Double) -> Pipe (h a) (TS f g a b c) m r

-- | A simple <a>Producer</a> of mini-batches.
simpleBatchP :: MonadRandom m => [a] -> Int -> Producer [a] m r

-- | A <a>Pipe</a> for progress reporting of model training.
reportTSP :: Monad m => Int -> (TS f g a b c -> m ()) -> Pipe (TS f g a b c) (TS f g a b c) m r

-- | A <a>Consumer</a> of training states that decides when training is
--   finished and then returns a value.
consumeTSP :: Monad m => (TS f g a b c -> m (Maybe x)) -> Consumer (TS f g a b c) m x


-- | This modules defines special "layer" components and convenience
--   functions for the creation of such layers.
module Numeric.Neural.Layer

-- | A <tt><a>Layer</a> i o</tt> is a component that maps a vector of
--   length <tt>i</tt> to a vector of length <tt>j</tt>.
type Layer i o = Component (Vector i Analytic) (Vector o Analytic)

-- | Creates a <i>linear</i> <a>Layer</a>, i.e. a layer that multiplies the
--   input with a weight matrix and adds a bias to get the output.
linearLayer :: (KnownNat i, KnownNat o) => Layer i o

-- | Creates a <a>Layer</a> as a combination of a linear layer and a
--   non-linear activation function.
layer :: (KnownNat i, KnownNat o) => (Analytic -> Analytic) -> Layer i o

-- | This is simply <a>layer</a>, specialized to <a>tanh</a>-activation.
--   Output values are all in the interval [0,1].
tanhLayer :: (KnownNat i, KnownNat o) => Layer i o

-- | This is simply <a>layer</a>, specialized to the logistic function as
--   activation. Output values are all in the interval [-1,1].
logisticLayer :: (KnownNat i, KnownNat o) => Layer i o

-- | The <a>softmax</a> function normalizes a vector, so that all entries
--   are in [0,1] with sum 1. This means the output entries can be
--   interpreted as probabilities.
softmax :: (Floating a, Functor f, Foldable f) => f a -> f a


-- | This module reexports all the neural network related modules for
--   convenience.
module Numeric.Neural
